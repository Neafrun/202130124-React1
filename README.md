# 이지훈 (학번: 202130124)
## 5월 15일(10주차)
#### Step4 State가 어디에 있어야 할 지 정하기 

이제 앱에서 최소한으로 필요한 state를 결정했습니다. 다음으로는 어떤 컴포넌트가 이 state를 소유하고, 변경할 책임을 지게 할 지 정해야 합니다. React는 항상 컴포넌트 계층구조를 따라 부모에서 자식으로 데이터를 전달하는 단방향 데이터 흐름을 사용하는 것을 기억하세요! 앱을 구현하면서 어떤 컴포넌트가 state를 가져야 하는 지 바로 명확하지 않을 수 있습니다. 이 개념이 처음이라면 더 어려울 수 있습니다. 그러나 아래의 과정을 따라가면 해결할 수 있습니다.

애플리케이션의 각 state에 대해서,

1. 해당 state를 기반으로 렌더링하는 모든 컴포넌트를 찾으세요.
2. 그들의 가장 가까운 공통되는 부모 컴포넌트를 찾으세요. - 계층에서 모두를 포괄하는 상위 컴포넌트
3. state가 어디에 위치 돼야 하는지 결정합시다
대개, 
1. 공통 부모에 state를 그냥 두면 됩니다.
2. 혹은, 공통 부모 상위의 컴포넌트에 둬도 됩니다.
3. state를 소유할 적절한 컴포넌트를 찾지 못하였다면, state를 소유하는 컴포넌트를 하나 만들어서 상위 계층에 추가하세요.
`이전 단계에서, 이 애플리케이션의 두 가지 state인 사용자의 검색어 입력과 체크박스의 값을 발견하였습니다. 이 예시에서 그들은 항상 함께 나타나기 때문에 같은 위치에 두는 것이 합리적입니다.`

이제 이 전략을 애플리케이션에 적용해 봅시다.

1. state를 쓰는 컴포넌트를 찾아봅시다:
ProductTable은 state에 기반한 상품 리스트를 필터링해야 합니다 (검색어와 체크 박스의 값)
SearchBar는 state를 표시해 주어야 합니다. (검색어와 체크 박스의 값)
2. 공통 부모를 찾아봅시다: 둘 모두가 공유하는 첫 번째 부모는 FilterableProductTable입니다
3. 어디에 state가 존재해야 할지 정해봅시다: 우리는FilterableProductTable에 검색어와 체크 박스 값을 state로 둘 겁니다.
이제 state 값은 FilterableProductTable안에 있습니다.

`useState() Hook을 이용해서 state를 컴포넌트에 추가하세요. Hooks는 React 기능에 “연결할 수(hook into)” 있게 해주는 특별한 함수입니다. FilterableProductTable의 상단에 두 개의 state 변수를 추가해서 초깃값을 명확하게 보여주세요.`
## 5월 8일(9주차)
### Step1 UI를 컴포넌트 계층으로 쪼개기
1. 먼저 모의 시안에 있는 모든 컴포넌트와 하위 컴퓨넌트 주변에 박스를 그리고, 그들에게 이름을 붙이면서 시작하기.
2. 디자이너와 함께 일한다면 그들이 이미 디자인 툴을 통해 컴포넌트에 이름을 정했을 수도 있다.
3. 어떤 배경을 갖고 있냐, 디자인을 컴포넌트로 나누는 방법에 대한 관점이 달라질 수 있다.
4. Programing : 새로운 함수나 객체를 만드는 방식과 같은 방법으로 하자.
- 이 중 단일책임 원칙을 반영하고자 한다면 컴포넌트는 이상적으로는 한 번에 한 가지 일만 해야 함.
- 만약 컴포넌트가 점점 커진다면 작은 하위 컴포넌트로 쪼개기.

### Step2 React로 정적인 버전 구현하기
1. 이제 컴포넌트 계층구조가 만들어졌으니, 앱을 실제로 구현 하자.
2. 가장 쉬운 접근 방법은 상호작용 기능은 아직 추가하지 않고, 데이터 모델로부터 UI를 렌더링하는 버전을 만드는 것.
3. 대체로 먼저 정적인 버전을 만들고 상호작용을 추가 하는게 더 쉽다.
4. 정적 버전을 만드는 것은 많은 타이핑이 필요하지만, 생각할 건 적다.
5. 반대로 상호작용 기능을 추가하는 것은 많은 생각이 필요하지만, 타이핑은 그리 많이 필요하지 않다.
- 데이터 모델을 렌더링하는 앱의 정적인 버전을 만들기 위해서는 다른 컴포넌트를 재사용하고, props를 이용해 데이터를 넘겨주는 컴포넌트를 구현하는 것이 좋다.
- props는 부모가 자식에게 데이터를 넘겨줄 때 사용할 수 있는 방법이다.

#### Step2에 있는 component 구현하기
1. Project를 새로 생성하거나, 초기 commit으로 switch하여 실행에 이상이 없는지 확인.
2. src/ 아래 필요 없는 파일을 제거하여
3. App.js에 있는 코드를 모두 삭제합니다.
4. 먼저 다음 코드로 App.js가 정상적으로 동작하는지 확인.
5. 사용할 데이터 PRODUCTS를 적당한 위치에 작성.
6. 다음으로 FilterableProductTable component를 만든다.

### Step3 최소한의 데이터만 이용해서 완벽하게 UI State 표현하기
1. UI를 상호작용 하게 만들려면, 사용자가 기반 테이터 모델을 변경할 수 있게 해야 합니다.
2. React는 state를 통해 기반 데이터 모델을 변결할 수 있게 합니다.
3. State는 앱이 기억해야 하는, 변경할 수 있는 데이터의 최소 집합이라고 생각합니다.
4. State를 구조화 하는데 가중 중요한 원칙은 중복배제원칙 입니다.
5. 애플리케이션을 필요로 하는 가장 최소한의 State를 파악하고, 나머지 모든 것들은 필요에 따라 실시간으로 계산합시다.
6. 예를 들어 쇼핑 리스트를 만든다고 하면 당신은 배열에 상품 아이템들을 넣을 겁니다.
7. UI에 상품 아이템의 개수를 노출하고 싶다면, 상품 아이템 개수를 따로 State 값으로 가지는 게 아니라 단순하게 배열의 길이만 쓰면 됩니다.

## 4월 18일(보강주)
### map함수의 사용

1. 원본 배열 (history): map이 호출된 원본 배열.
2. 원본 배열의 인덱스 (move): 현재 순환 중인 원본 배열 요소의 인덱스.
3. 요소 값 (squares): 현재 순회 중인 요소 배열의 값.
4. history.map((squares, move)=> {... })는 다음과 같이 동작합니다.

- 첫 번째 호출: squares = `[null, null, null, null, null, null, null, null, null], move= 0`
- 두 번째 호출: Squares = `['X', null, null, null, null, null, null, null, null], move = 1`
- 세 번째 호출: squares = `['X', 'o', null, null, null, null, null, null, null], move =2`
1. 각각의 history 요소에 대한 {  }의 실행문(후작업) 실행합니다.
2.  moves 객체에 저장합니다.
3.  최종 출력에 사용합니다.

### key 선택하기

1. key는 React에서 특별하게 미리 지정된 프로퍼티입니다.
2. 엘리먼트가 생성되면 React는 key 프로퍼티를 추출하여 반환되는 엘리먼트에 직접 key를 저장합니다.
3. key가 props로 전달되는 것처럼 보일 수 있지만, React는 자동으로 key를 사용해 업데이트할 컴포넌트를 결정합니다.
4. 부모가 지정한 key가 무엇인지 컴포넌트는 알 수 없습니다.
5. 동적인 리스트를 만들 때마다 적절한 Key를 할당하는 것을 강력하게 추천합니다.
6. 적절한 key가 없는 경우 데이터의 재구성을 고려해 보세요.
7. key가 지정되지 않은 경우, React는 경고를 표시하며 배열의 인덱스를 기본 key로 사용합니다.
8. 배열 인덱스를 key로 사용하면 리스트 항목의 순서를 바꾸거나 항목을 추가/제거할 때 문제가 발생합니다.
9. 명시적으로 key={i}를 전달하면 경고는 사라지지만 배열의 인덱스를 사용할 때와 같은 문제가 발 생하므로 대부분은 추천하지 않습니다.


## 4월 17일(7주차)
### Static에 대하여
1. 자바 언어 예약어로 클래스 메서드와 클래스 필드를 지정할 때 사용한다.
2. 인스턴스를 생성하지 않아도 클래스의 메서드와 필드에 접근을 가능하게 한다.

### Static의 장점
Static은 두가지 장점을 가진다.
1. 첫번째는, Static이 메모리 측면에서 효율적일 수 있다는 점이다.
Static 메모리 영역에 저장되어 고정된 메모리 영역을 사용하기 때문에 매번 인스턴스를 생성하며 낭비되는 메모리를 줄일 수 있다.

2. 두번째는, 객체를 생성하지 않고 사용가능 하기 때문에 속도가 빠르다는 것이다. 클래스가 메모리에 올라가는 시점에 생성되어 바로 사용이 가능하기에 속도면에서 이점을 가진다.

### Stactic의 단점
1. Static 키워드는 크게 세가지 단점을 가진다.
첫번째는, 프로그램 종료시까지 메모리에 할당된 채로 존재한다는 것이다.
우리가 만든 Class는 프로그램 실행시 Static 영역에 생성된다.
그런데, Garbage Collector를 통해 수시로 관리를 받는 Heap 영역과 다르게 Static 영역은 Garbage Collector의 관리를 받지 않는다. 그래서 Static 영역은 프로그램 종료시까지 메모리에 존재 한다.
만약 프로그램에서 많은 Static을 사용하게 되면 종료시까지 메모리가 할당된 채로 존재하므로 프로그램 퍼포먼스에 악영향을 주게 된다.

2. 두번째는, Static이 객체지향적이지 못하다는 점이다.
Static은 따로 객체를 생성하지 않고 메모리의 Static영역에 할당된 곳에서 여러 클래스들이 데이터를 불러온다.
이러한 Static의 특징은 객체의 데이터들이 캡슐화되어야 한다는 객체지향 프로그래밍의 원칙을 위반한다.

3. 세번째는 Static 메서드는 Interface를 구현하는데 사용될 수 없다는 점이다. Static 메서드는 코드의 재사용성을 높여주는 자바의 유용한 객체지향적 기능(Interface 등)을 사용하는 것을 방해한다.

### 2. 불변성이 중요한 이유

#### 1. 유지 이유

React는 상태(State)를 업데이트할 때, 이전 상태와 새로운 상태를 비교하여 렌더링을 결정한다. 이를 위해 React는 얕은 비교(Shallow Comparison)를 수행하는데, 이는 객체나 배열의 참조 주소만 비교한다는 의미이다.
 
만약 상태를 업데이트할 때 불변성을 유지하지 않으면, 이전 상태와 새로운 상태가 동일한 참조를 가리키게 되어 React가 상태 변화를 감지하지 못할 수 있다. 이는 컴포넌트 최적화를 위해 React.memo와 같은 기능을 사용할 수 없게 된다.
불변성을 유지하지 않으면 React는 상태 변화를 올바르게 감지하지 못해 해당 컴포넌트가 업데이트되어야 하는지 여부를 판단하기 어려워진다. 그 결과, 컴포넌트가 불필요하게 다시 렌더링되어 성능이 저하될 수 있다.

### 2. 불변성의 장단점

#### 불변성의 장점

불변성은 상태 변화를 예측 가능하게 만들어서 디버깅이 쉽고, 병렬 처리 및 캐싱 등의 최적화를 가능하게 한다. 또한 함수형 프로그래밍의 개념을 적용하여 코드를 보다 간결하고 안정적으로 만들 수 있다.
 
#### 불변성의 단점

불변성을 유지하는 과정에서 메모리 사용량이 증가할 수 있고, 복잡한 객체나 배열을 다룰 때 번거로움을 초래할 수 있다. 또한 가변성을 허용하지 않기 때문에 일부 상황에서는 처리 속도가 저하될 수 있다.


## 4월 10일(6주차)
#### 6주차 학습내용

#### 1. useState 사용법
##### 사용자와 상호작용하는 컴포넌트 만들기

1. 파일 상단에 useState를 Import합니다.
2. Square 컴포넌트에서 value porp을 제거합니다. 대신 useState를 사용합니다.
3. Square 컴포넌트의 시작 부분에 useState를 호출하고, value라는 이름의 state 변수를 변환하도록 한다.

##### state 끌어올리기

1. Board 컴포넌트를 편집해서 9개 Square에 해당하는 9개의 null의 배열을 기본값으로 하는 state 변수 squares를 선언.

` //...
export default function Board() {
    const [squares, setSquares] = useState(Array(9),fill(null));
    return (
        //...
    ); 
} `
- Array(9).fill(null)은 9개의 엘리먼트로 배열 생성, 각 엘리먼트를 null로 설정 함. (참고 : developer.mozilla.org) 
- state 변수 squares와 함수 setSquares 선언.
- 배열의 각 항목은 각 Square 컴포넌트의 값에 해당.
- 보드를 채우면, squares 배열은 다음과 같은 모양이 됨.

` ['o', null, 'x', 'x', 'x', 'o', 'o', null, null,]`

#### 2. 컴포넌트 분리하기
- 문서에서는 Board와 Square를 함께 두었지만 우리는 모두 분리합니다.

1. component이름과 동일한 파일을 만듭니다.
2. 해당 파일에 코드를 복사하고 export default 키워드를 추가 합니다.
3. 필요한 component와 useState를 추가합니다.
4. App.js에서 해당 코드를 삭제하고, Board component를 import해 줍니다.
5. App.js에서 useState의 import를 제거합니다.
6. 정상적으로 동작하는지 확인힙니다.

## 4월 3일(5주차)
#### 5주차 학습내용
#### 1. Hook사용하기
- use로 시작하는 함수를 hook이라고 함.

- 훅은 리액트 클래스형 컴포넌트에서 이용하던 코드를 작성할 필요없이 함수형 컴포넌트에서 다양한 기능을 사용할 수 있게 만들어준 라이브러리라고 할 수 있는데 React 16.8버전에 새로 추가된 기능이다. 이는 함수형 컴포넌트에 맞게 만들어진 것으로 함수형 컴포넌트에서만 사용 가능하다.

#### 2. hooks의 사용 규칙

##### 최상위에서만 Hook을 호출해야한다.

- 반복문이나 조건문 혹은 중첩된 함수 내에서 Hook을 호출하면 안된다.

- 리액트 훅은 호출되는 순서에 의존하기 때문에 조건문이나 반복문 안에서 실행하게 될 경우 해당 부분을 건너뛰는 일이 발생할 수도 있기 때문에 순서가 꼬여 버그가 발생할 수 있다. 

- 그렇기 때문에 이 규칙을 따르면 useState 와 useEffect가 여러번 호출되는 경우에도 Hook의 상태를 올바르게 유지할 수 있게 된다.

- Hook은 React의 렌더링 및 상태 관리 메커니즘과 밀접하게 연결되어 있으며, 아래와 같은 규칙을 따라야 함.

**if, for, while 등의 블록 내부에서 Hooks를 호출하면 안 됨.
 함수의 조건문 내부에서 호출하면 실행 순서가 달라질 수 있기 때문.**


##### 리액트 함수 내에서만 Hook을 호출해야한다.

- Hook은 일반적인 js 함수에서는 호출하면 안된다.

- 함수형 컴포넌트나 custom hook에서는 호출 가능하다.

- React 함수형 component 또는 사용자 Hook 내부에서만 사용 가능.

- 일반적인 JavaScript 함수에서 useState, useEffect 등의 Hook을 사용 할 수 없음.

### 왜 function형 컴포넌트에서만 Hook을 사용할까?

- class형 component는 lifecycle 함수를 통해 상태 관리를 했음.
- 그런 이유 떄문에 class형 component는 유지보수가 어렵고 복잡해질 수 있음.
- React는 component의 상태 관리(lifecycle) 와 로직을 더 간결하게 만들기 위해 Hooks를 사용.
 
 


## 3월 27일(4주차)
#### 4주차 학습내용
1. component 생성 및 nesting(중첩)
- component는 고유한 로직과 모양을 가진 UI의 일부
- component는 버튼처럼 작을 수도 있고, 전체 페이지처럼 클 수도 있음.
- component는 마크업를 변환(return)하는 JavaScript 함수.

- export default 키워드는 파일내의 componen중 기본 component를 지정합니다.
- 이 키워드의 사용도 JavaScript 문법입니다.
> 좀더 구체적으로 알고 싶다면 사이트의 MDN혹은 javascript.info 링크를 확인하세요.

2. 스타일 추가하기
- React에서는 className으로 CSS클래스를 지정합니다.
- className은 HTML의 class 속성과 동일한 방식으로 동작합니다.
- CSS 규칙은 별도의 CSS 파일에 작성합니다. 그런데 React는 CSS 파일을 추가하는 방법을 규정하지는 않습니다.
> 정적 페이지를 작성할 때와 동일한 방법을 지원합니다.

- 가장 가단한 방법은 HTML에 link 태그를 추가하는 것.
> 그러나 link를 추가하면 정적 페이지를 수정해야 하기 떄문에 추천 x

3. 조건부 렌더링

- React에서 조건문을 작성하는데에는 특별한 문법이 필요 없습니다.
- 일반적인 자바스크립트 코드를 작성할 때 사용하는 것과 동일한 방법을 사용합니다.

4. 리스트 렌더링

- 컴포넌트 리스트를 렌더링하기 위해서는 for문 및 map() 함수와 같은 자바스크립트 기능을 사용합니다.
- il에 key 속성arrtibute이 있는 것을 주목해야함.
- 목록을 사용할 때는 각 항목에 대해 고유하게 식별하는 문자열 또는 숫자를 전달해야 함.
- 항목을 삽입, 삭제 또는 재정렬할 때 어떤 일이 일어났는지 알기 위해 Key를 사용.


## 3월20일(3주차)
#### 의존성 관리와 package.json
> 의존성이란 하나의 소프트웨어가 다른 소프트웨어에 의지하여 동작하는 걸 말한다. 즉 어떤 프로젝트에 사용된 각종 패키지 등의 버전을 동일하게 유지하기 위한 것.

#### 중요사항 
- 협업을 할 때는 팀원들 각자의 컴퓨터에 같은 패키지를 설치해 동일한 개발 환경 구성.
코드는 GitHub등 Git Server를 이용하지만, 노드 패키지는 각 팀원들이 설치해야 함.
의존성을 무시하면 다른 버전의 패키지를 설치 및 개발 프로젝트 오류 발생.

**개인의 경우도 GitHub에 코드를 내려 받은 후 개발 해야 할 수도 있음.**

#### 의존성을 관리하는 이유
- npm install 또는 Yarn install 한 줄로 모든 의존성 자동 설치 가능.
특정 버전의 라이브러리 쉽게 업데이트 가능.
package-lock.json을 활용하면 동일한 패키지를 정확한 버전으로 설치 가능.

#### 중복 설치 방지
- 필요 없는 라이브러리 제거하여 프로젝트를 가볍게 유지 가능.

**package.json은 이런 의존성을 체계적으로 관리하는 역활을 함. 프로젝트에 필요한 라이브러리를 쉽게 설치하고 업데이트를 유지할 수 있도록 도와줌.**

### node module 재설치

1. node modules 폴더와 package-lock.json 파일 삭제
`$rm -rf node modules package-lock.json`

2. npm 패키지의 임시 저장소인 cache 초기화
`$npm chche clean --force`

3. 패키지를 다시 설치
`$ npm install`

#### 삭제하는 이유 
- package-lock.json 손상 및 잘못된 의존성.
- 최신 버전의 패키지를 다시 받고 싶을 때
- 팀 프로젝트에서 다른 팀원이 이상한 상태로 package-lock.json을 업데이트 한 경우.

#### ***모든 플랫폼에서 최고의 성능을 발휘하는 React***
1.  리액트를 사용하면 동일한 기술을 사용하여, 웹 앱과 네이티브 앱을 모두 구축 할 수 있음.
2. 각 플랫폼의 고유한 강점을 활용하여 모든 플랫폼 잘 어울리는 인터페이스를 구현할 수 있음.

**기본적으로 사람들은 빠른 웹을 사용하고 싶음.**

1. 사람들은 네이티브 앱이 자신의 플랫폼과 같은 모양의 느낌을 주기를 원한다. React Nativ와 Expo를 사용하면 Android, IOS 등을 위한 앱을 리액트로 빌드할 수 있음.

2. 앱이 네이티브처럼 보이고 느껴지는 이유는 UI가 네이티브이기 때문 즉 Web 뷰가 아니라 플랫폼에서 제공하는 Android 및 IOS View를 사용하기 때문.

3. 리액트를 사용하면 앱 개발자도 네이티브 개발자도 될 수 있고 사용자 경험의 희생 없이 다양한 플랫폼에 앱을 출시 가능

4. 기업에서는 플랫폼 간의 장벽을 허물고, 전체 기능을 협업을 통해 개발할 수 있는 팀을 구성할 수 있음.

## 3월13일(2주차)
### Node.js의 대하여

- Node.js는 JavaScript를 기반으로 사용하여 JavaScript는 개발 공부를 처음 한 사람도 쉽게 익힐 수 있을 만큼 난이도가 낮다. 개발자 커뮤니티가 잘 돼 있다.

- Node.js는 개발자들 사이에서 인기가 높기 때문에 커뮤니티에는 이미 개발자들이 만들어 공유한 다양한 패키지들이 있다. 그래서 npm을 잘 활용하면 유용한 기능들을 쉽게 구현할 수 있다.

- Node.js를 학습한다는건 JavaScript를 활용할 줄 알게 된다는 사실이라서
Node를 배운다는건 프론트엔드 부터 풀스택 개발자 까지도 가능하다는 것.
프론트 엔드 영역도 쉽게 파악 할 수 있다는 것에 대단함을 느낌.

- Node.js는 가볍고 빠른 서비스에 어울린다고 전에 배운 게 생각이 났다
다른 무거운 언어 Java를 Node랑 비교 하면 훨 무겁다고 들었다 특히 javaPlugin , Module을 추가해 구성하면 Node.js가 얼마나 빠르고 가벼운지를 알 수 있을 것이다.

**스트리밍 사이트로 유명한 ott 넷플릭스가 있는데 이 사이트도 Node를 활용하여 안정적인 서비스를 제공하고 있는 걸로 알고있다.**


# React
### React에 대하여

리액트를 공부하기 전 앞서 리액트에 대해 알아보자

- 리액트(React)는 Facebook(현재 Meta)에서 개발한 프론트엔드 라이브러리입니다. 주로 사용자 인터페이스(UI)를 개발하는 데에 중점을 두고 있죠. 이 라이브러리를 사용하면 실시간 대시보드, 소셜 미디어 애플리케이션, 전자상거래 플랫폼과 같은 다양한 종류의 웹 애플리케이션을 쉽게 만들 수 있습니다.
리액트는 프론트엔드 개발자들 사이에서 매우 인기가 높은 도구입니다. 활발한 커뮤니티와 다양한 라이브러리와의 호환성을 통해 개발자들이 쉽게 정보를 공유하고 협업할 수 있기 때문인데요. 리액트가 많은 개발자들에게 사랑받고 있다는 사실은 다양한 설문조사와 통계 데이터에서 확인할 수 있습니다.

- React는 사용자 인터페이스를 구축하기 위한 선언적이고 효율적이며 유연한 JavaScript 라이브러리입니다. “컴포넌트”라고 불리는 작고 고립된 코드의 파편을 이용하여 복잡한 UI를 구성하도록 돕습니다.

### React 장점
1. 개발 생산성이 높다
화면에 구성되는 요소들을 하나하나 개발하지 않고 반복되는 것들은 컴포넌트를 재사용해 생산성을 높일 수 있습니다. 마치 레고 조립으로 수많은 형태를 완성하는 형식과 비슷합니다. 오류가 생겼을 때도 전체 페이지를 수정하는 대신 해당 컴포넌트만 수정하면 되기 때문에 문제 해결도 쉽습니다.
​
2. 입문자도 흥미를 쉽게 느낄 수 있다
학습 커브가 높지만, 전세계적으로 활용도가 높아서 커뮤니티 도움이나 다양한 학습 자료를 활용하면 입문자도 빠르게 개발을 시작할 수 있어요. 기초적인 프로그래밍 지식만 있어도 손쉽게 앱 개발을 경험할 수 있습니다.
​
3. 사용하는 기업이 많다
전 세계 65만 개 프론트엔드 채용 공고를 분석한 결과, 리액트 채용 공고는 약 35만 5000개 정도로 압도적인 1위를 차지했습니다. 국내에서도 11번가, 티몬, 오피지지, 카카오페이 등 수많은 기업에서 프론트엔드 개발에 리액트를 사용하고 있습니다.

### 개발 플랫폼
1. Node.js
확장성 있는 네트워크 애플리케이션(특히 서버 사이드) 개발에 사용되는 소프트웨어 플랫폼이다.
작성 언어로 자바스크립트를 활용한다.
안정적이고 신뢰도가 높은 LTS 버전, 최신 기능이 포함된 Current 버전이 있다.
→ 이번 프로젝트에서는 안정성 보장을 위해 LTS 버전을 사용

### 패키지 관리자
1. npm
- Node.js를 설치할 때 함께 설치되는 기본 패키지 관리자이다.
- 사람들이 만들어 온라인 플랫폼에 게시한 패키지를 쓸 수 있다.
- 패키지를 한 번에 하나씩 설치한다.
- 보안 측면에서 yarn보다 취약하다는 문제가 있는 것으로 알려졌으나, 최근에는 업데이트를 통해 보안 문제를 많이 해결한 것으로 보인다.

2. yarn
- 여러 패키지를 동시에 설치하기 때문에 패키지 설치는 npm보다 빠르다.
- yarn.lock 또는 package.json 파일에 있는 것만을 설치한다.
`npm install yarn --global`

### 상태 관리 라이브러리

-상태 관리는 여러 컴포넌트들 간에 데이터를 공유하는 방법이다. 이 상태(state)는 자식 컴포넌트에게만 전달할 수 있는데, 컴포넌트가 많아지고 복잡해질 수록 이 상태를 전달하는 것이 어려워진다.

**이 문제를 해결하기 위해서 사용하는 것이 상태 관리 라이브러리로, 상태를 전역 변수처럼 만들어 모든 컴포넌트에서 접근이 가능하도록 만들어 준다.**

1. Redux

JavaScript 앱에 사용하는 상태 관리 라이브러리이다. React, Vue 등 다른 라이브러리와 함께 사용한다.
현재 상태 관리 라이브러리로 가장 많이 사용되고, 값의 변경 사항을 DevTools를 이용해 확인할 수 있다. 신뢰성 있는 검증된 라이브러리이다.

`$yarn add @reduxjs/toolkit`

2. Recoil

React를 활용한 앱에 사용하는 상태 관리 라이브러리이다.
React를 써본 사람이면 금방 이해할 만한 직관적이고 간단한 구조로 이루어져 있고, 코드의 양이 Redux에 비해 적은 편이다. 사용하는 방식이 React에 가깝다고 볼 수 있다.

`$yarn add recoil`

### 웹 컴포넌트 스타일링

#### 1. CSS-in-JS

- JavaScript 코드에서 CSS를 작성하는 방식이다. 중복되는 클래스네임을 고려할 필요가 없으며, JS 코드와 CSS가 상태값을 공유할 수 있어 개발이 편리하다는 장점이 있다.

- 하지만 타인이 코드를 이해하려면 두 번 왔다갔다 해야 한다는 단점이 있다.

##### Styled Components

 - props에 따라 다른 스타일을 적용하는 기능을 제공한다.

- props가 많아지면 …props의 형태로 넘겨서 사용이 가능하다.

- CSS-in-JS 라이브러리로 가장 많이 사용되고, 전역 스타일 적용(다크모드 등)에 편리한 듯하다.

##### Emotion
- styled-components 보다 퍼포먼스가 전반적으로 좋게 나온다는 평이 있다.

- JSX 안에서 해당 태그가 어떤 태그인지 바로 알 수 있다. styled-components는 이게 안 된다.

- @emotion/react, @emotion/styled

- CSS props를 결합할 수 있다.

#### 2. CSS-in-CSS

- CSS를 모듈화하여 사용한다. 사용자가 정의한 클래스네임과 자동으로 만들어진 고유한 클래스네임을 만들어 scope를 제한하는 방식이다. JavaScript 해석 과정이 따로 없기 때문에 훨씬 빠르다.

### 명령어 정리

> npx create-react-app (프로젝트 명)

> cd jihoon (생성한 프로젝트 폴더로 이동)

> npm start

> npm install react-router-dom (react-router-dom 설치)

### 필요 모듈 설치
> npm init -y

> npm install express

>npm install cors

>npm install --save-dev nodemon

>npm install axios



